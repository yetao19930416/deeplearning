第四部分第一周（卷积神经网络）

边缘检测
首先需要一个过滤器（3乘以3）
图片为（6乘以6乘以1）因为是灰色图像
最后经过过滤器卷积运算为4乘以4

实现卷积运算：
    python：conv-forward
    tensorflow：tf.nn.conv2d
    keras :conv2d

padding填充
图片为n*n（6 * 6）
过滤器为f*f（3 * 3）
卷积运算得4*4
  （n-f+1）*（n-f+1）
  缺点：1、每次做卷积操作，你的图像都会缩小
       2、边缘，角落区域的像素点在输出层采用少，信息会丢失不少
  解决方法：在原图填充一层
        以6乘以6变成8乘以8
        P=padding（填充）    （n+2P-f+1）*（n+2P-f+1）

  Valid卷积：意味着不填充：n乘以n * f乘以f -》n-f+1乘以n-f+1
                        6乘以6 * 3乘以3 -》4乘以4

  Same卷积：填充后你的输出大小和你的输入大小一样
          （n+2P-f+1）乘以（n+2P-f+1）       
     如果想 n+2P-f+1=n
               P=（f-1）/2 （过滤器通常是奇数）

   卷积步长
    strid=s=2（往后移2步，多移一步）
    padding=p
    （n+2p-f）/s +1 *（n+2p-f）/s +1 
    如果不是整数的向下取整（就是只要有一个计算在外面就不进行计算）

    数学教材要把过滤进行水平垂直翻转（翻2次）

    三维卷积
    （6*6*3）图像3为通道数  * 3*3*3（过滤器） = 4乘以4
     （图像通道数必须和过滤器通道数相同）
     summary（纬度）：n*n*nc（通道） * f*f*fc=》（n-f-1）*（n-f+1）*nc‘（用到过滤器个数）

$f^{[l]}$ = 过滤器大小
$p^{[l]}$ = padding数量
$s^{[l]}$ = 步伐
$nc^{[l]}$= 通道数量
Input：$nh^{[L-1]}$乘以$nw^{[L-1]}$乘以$nc^{[L-1]}$
Output：$nh^{[L]}$乘以$nw^{[L]}$乘以$nc^{[L]}$
$nw^{[L]}$= （$nw^{[L-1]}$+$2p^{[L]}$-
$f^{[L]}$）/$s^{[L]}$   +1

     （Conv）卷积层
     （POOl）池化层
     （FC）全连接层
     池化层：缩减模型大小，提高计算速度
     最大池化取最大值
     平均池化取平均值（不怎么常用）

     池化超级参数：过滤器大小，步伐s，常用值f=2，s=2
     input： =nH乘以nw乘以nc
     输出 =  [(nH-f)/s+1]乘以[(nw-f)/s+1]乘以nc

     卷积神经运行过程记笔记本上了

     卷积层优势：参数共享，稀疏链接






